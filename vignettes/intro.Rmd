---
title: "intro"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(messy.cats)
library(dplyr)
library(ggplot2)
library(stringdist)
library(varhandle)
library(rapportools)
```
Messy.cats contains various functions that employ string distance tools in order to make data management easier for users working with categorical data. Categorical data, especially user inputted categorical data that often tends to be plagued by typos and different formatting choices, can be difficult to work with. Messy.cats aims to provide functions that make cleaning categorical data simple and easy.

This introduction will lead you through examples of the functions in use, explain the arguments, and show how to get the most out of these functions. 

First lets create some example vectors:
```{r car lists}
cars_bad = c("teal Mazda RX4", "black Mazda RX4 Wag",
             "green Datsun 710", "Hornet 4 Drive",
           "green Hornet Sportabout", "Valiant",
           "Duster 360", "orange Merc 240D",
           "Merc 230", "teal Merc 280",
           "Merc 280C", "green Merc 450SE",
           "Merc 450SL", "blue Merc 450SLC",
           "green Cadillac Fleetwood", "Lincoln Continental",
           "Chrysler Imperial", "Fiat 128",
           "red Honda Civic", "Toyota Corolla",
           "Toyota Corona", "Dodge Challenger",
           "red AMC Javelin", "Camaro Z28",
           "Pontiac Firebird", "black Fiat X1-9",
           "blue Porsche 914-2", "Lotus Europa",
           "Ford Pantera L", "black Ferrari Dino",
           "black Maserati Bora", "black Volvo 142E")

cars_good = c("Mazda RX4", "Mazda RX4 Wag",
              "Datsun 710", "Hornet 4 Drive",
           "Hornet Sportabout", "Valiant",
           "Duster 360", "Merc 240D",
           "Merc 230", "Merc 280",
           "Merc 280C", "Merc 450SE",
           "Merc 450SL", "Merc 450SLC",
           "Cadillac Fleetwood", "Lincoln Continental",
           "Chrysler Imperial", "Fiat 128",
           "Honda Civic", "Toyota Corolla",
           "Toyota Corona", "Dodge Challenger",
           "AMC Javelin", "Camaro Z28",
           "Pontiac Firebird", "Fiat X1-9",
           "Porsche 914-2", "Lotus Europa",
           "Ford Pantera L", "Ferrari Dino",
           "Maserati Bora", "Volvo 142E")



# load in messy_caterpillars and clean_caterpillars
data("clean_caterpillars")
data("messy_caterpillars")
```

In this example suppose these lists of cars are columns in dataframes you want to join. One column has color included in the make and model of the car, and the other does not. Instead of string processing and deleting the color descriptors, cat_match() can 
```{r first cat_match example}
x = cat_match(cars_bad, cars_good, method = "jw")
x
```

```{r changing the method}
x = cat_match(cars_bad, cars_good, method = "jaccard")

```

```{r threshold cat_match example}

```



In this example we have two datasets, the first: `messy_caterpillars` contains information about the average weight and length of caterpillars, and as the name suggests, has messy very caterpillar names.

`clean_caterpillars` is a dataset containing the species and number of caterpillars you found over the last 3 summers. 

If you want to calculate how much caterpillar you actually saw in both centimeters and and milligrams, you'll have to fix those messy names somehow.
```{r return_lists cat_match example,eval=F}
head(messy_caterpillars)
str(messy_caterpillars)

head(clean_caterpillars)
str(clean_caterpillars)
```

To fix these names we can either use `cat_replace()` and change the 

In order to properly configure our string distance arguments, we will first use `cat_match()` to explore how the messy and clean caterpillar names match up.

We input the messy and clean vectors—in this case columns of caterpillar names—and specify no other arguments other than to return the distance between each string pair.
```{r pick_lists cat_match example,eval=F}
cat_match(messy_caterpillars$CaterpillarSpecies,
          clean_caterpillars$species,
          return_dists = T)
```
The output shows the clean string with the lowest string distance from each messy string, and the distance between the pair is returned as a third column. 

If we arrange by the distance in descending order, we can see the items of the messy vector with the worst matches. As we scroll through we can see that first species from the messy list of species we have recorded in the clean dataset is "Pyreferra hespridago". If there are no incorrect matches with a lower string distance, we could simply use `cat_replace()` or `cat_join()` with a threshold set just above this match. Unfortunately if you look at the next record, "Lithophane patefacta", a species that wasn't in our clean dataset, but was incorrectly matched to another species in the Lithophane genus. 
```{r using outputs cat_match example,eval=F}
cat_match(messy_caterpillars$CaterpillarSpecies,clean_caterpillars$species,return_dists = T,method="jaccard") %>% arrange(desc(dists))
```

```{r}


```

```{r using outputs inner_join,eval=F}
messy_caterpillars$CaterpillarSpecies = cat_replace(messy_caterpillars$CaterpillarSpecies,clean_caterpillars$species,threshold=0.12)

left_join(clean_caterpillars,messy_caterpillars, by = c("species"="CaterpillarSpecies"))
```
